<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Interactive Particle System</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<style>
body { margin: 0; overflow: hidden; background: #000; }
#cam { position: fixed; top: 12px; right: 12px; width: 180px; height: 130px; border-radius: 12px; overflow: hidden; border: 2px solid rgba(200,150,255,0.5); box-shadow: 0 0 20px rgba(200,150,255,0.6); }
#cam video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
#hint { position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%); color: #ccc; font-family: system-ui; font-size: 14px; }
</style>
</head>
<body>

<div id="cam"><video id="video" autoplay playsinline muted></video></div>
<div id="hint">Click once • Move hand to rotate/tilt • Pinch to scale • Open hand to expand • Two hands to change shape</div>

<script>
// ===================
// THREE.JS SETUP
// ===================
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 5, 25);
const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.z = 12;
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ===================
// PARTICLES
// ===================
const COUNT = 15000;
const positions = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({ size: 0.05, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
const particles = new THREE.Points(geometry, material);
scene.add(particles);

// ===================
// SHAPE TEMPLATES
// ===================
let templateIndex = 0;
const templates = {
  sphere: i => {
    const phi = Math.acos(2 * Math.random() - 1);
    const theta = Math.random() * 2 * Math.PI;
    const r = 5 * Math.cbrt(Math.random());
    return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
  },
  heart: i => {
    const t = Math.random() * Math.PI * 2;
    const r = Math.sqrt(Math.random());
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    return [x*0.05*r, y*0.05*r, (Math.random()-0.5)];
  },
  ring: i => {
    const angle = Math.random() * 2 * Math.PI;
    const radius = 4 + Math.random()*1;
    return [Math.cos(angle)*radius, (Math.random()-0.5)*1.5, Math.sin(angle)*radius];
  },
  fireworks: i => {
    const v = new THREE.Vector3().randomDirection().multiplyScalar(Math.random()*3);
    return [v.x, v.y, v.z];
  }
};
const templateKeys = Object.keys(templates);

function applyTemplate() {
  for(let i=0;i<COUNT;i++){
    const [x,y,z] = templates[templateKeys[templateIndex]](i);
    positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
    colors[i*3] = Math.random(); colors[i*3+1] = Math.random(); colors[i*3+2] = 1;
  }
  geometry.attributes.position.needsUpdate = true;
  geometry.attributes.color.needsUpdate = true;
}
applyTemplate();

// ===================
// HAND TRACKING
// ===================
let scale = 1, colorShift = 0, lastHands = 0;
let rotationX = 0, rotationY = 0;

const hands = new Hands({ locateFile: f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 2, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.7 });

hands.onResults(results => {
  const count = results.multiHandLandmarks?.length || 0;
  if(count>=1){
    const lm = results.multiHandLandmarks[0];
    // Rotate/tilt
    rotationY = (lm[0].x-0.5)*Math.PI*2;
    rotationX = (lm[0].y-0.5)*Math.PI;
    // Scale via pinch distance
    const d = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
    scale = THREE.MathUtils.clamp(d*8, 0.5, 3);
    // Color shift via open hand distance
    const open = Math.hypot(lm[0].x-lm[12].x, lm[0].y-lm[12].y);
    colorShift = open*5;
  }
  if(count===2 && lastHands!==2){
    templateIndex = (templateIndex+1)%templateKeys.length;
    applyTemplate();
  }
  lastHands = count;
});

// ===================
// CAMERA
// ===================
const video = document.getElementById('video');
let cam=null;
async function startCamera(){
  if(cam) return;
  cam=new Camera(video,{ onFrame: async()=> video.readyState>=2 && hands.send({image:video}), width:640, height:480 });
  cam.start();
}
addEventListener('click', startCamera, {once:true});

// ===================
// ANIMATE
// ===================
function animate(){
  requestAnimationFrame(animate);
  particles.rotation.x += (rotationX-particles.rotation.x)*0.05;
  particles.rotation.y += (rotationY-particles.rotation.y)*0.05;
  particles.scale.setScalar(scale);
  const c = geometry.attributes.color.array;
  for(let i=0;i<c.length;i+=3){ c[i]=0.5+0.5*Math.sin(performance.now()*0.002+colorShift); }
  geometry.attributes.color.needsUpdate=true;
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
</script>
</body>
</html>
