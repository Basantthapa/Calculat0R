<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Interactive Particle Vortex - Mobile Friendly</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<style>
body { margin:0; overflow:hidden; background:#000; }
#cam { position:fixed; top:12px; right:12px; width:150px; height:110px; border-radius:12px; overflow:hidden; border:2px solid rgba(200,150,255,0.5); box-shadow:0 0 20px rgba(200,150,255,0.6); }
#cam video { width:100%; height:100%; object-fit:cover; transform:scaleX(-1); }
#hint { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); color:#ccc; font-family:system-ui; font-size:12px; text-align:center; }
</style>
</head>
<body>

<div id="cam"><video id="video" autoplay playsinline muted></video></div>
<div id="hint">Click to start • Move hand to rotate/tilt • Pinch to scale • Open hand to expand • Two hands to switch shape • Touch fallback enabled</div>

<script>
const isMobile = /Mobi|Android/i.test(navigator.userAgent);
const COUNT = isMobile ? 4000 : 10000; // lighter particle count on mobile

// THREE.js Setup
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000,5,30);
const camera = new THREE.PerspectiveCamera(65,window.innerWidth/window.innerHeight,0.1,100);
camera.position.z=15;
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

// Particles
const positions=new Float32Array(COUNT*3);
const velocities=new Float32Array(COUNT*3);
const colors=new Float32Array(COUNT*3);
const geometry=new THREE.BufferGeometry();
geometry.setAttribute('position',new THREE.BufferAttribute(positions,3));
geometry.setAttribute('color',new THREE.BufferAttribute(colors,3));
const material=new THREE.PointsMaterial({size:0.05,vertexColors:true,transparent:true,blending:THREE.AdditiveBlending});
const particles=new THREE.Points(geometry,material);
scene.add(particles);
for(let i=0;i<COUNT;i++){
  positions[i*3]=(Math.random()-0.5)*20;
  positions[i*3+1]=(Math.random()-0.5)*20;
  positions[i*3+2]=(Math.random()-0.5)*20;
  velocities[i*3]=(Math.random()-0.5)*0.01;
  velocities[i*3+1]=(Math.random()-0.5)*0.01;
  velocities[i*3+2]=(Math.random()-0.5)*0.01;
  colors[i*3]=Math.random();
  colors[i*3+1]=Math.random();
  colors[i*3+2]=1;
}
geometry.attributes.position.needsUpdate=true;
geometry.attributes.color.needsUpdate=true;

// Hand Tracking Variables
let scale=1, rotationX=0, rotationY=0, colorShift=0, lastHands=0;
let vortexCenter=new THREE.Vector3(0,0,0);

const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.7,minTrackingConfidence:0.7});
hands.onResults(results=>{
  const count=results.multiHandLandmarks?.length||0;
  if(count>=1){
    const lm=results.multiHandLandmarks[0];
    rotationY=(lm[0].x-0.5)*Math.PI*2;
    rotationX=(lm[0].y-0.5)*Math.PI;
    const d=Math.hypot(lm[4].x-lm[8].x,lm[4].y-lm[8].y);
    scale=THREE.MathUtils.clamp(d*6,0.5,2.5);
    const open=Math.hypot(lm[0].x-lm[12].x,lm[0].y-lm[12].y);
    colorShift=open*4;
    vortexCenter.x=(lm[0].x-0.5)*15;
    vortexCenter.y=-(lm[0].y-0.5)*15;
    vortexCenter.z=0;
  }
  lastHands=count;
});

// Camera
const video=document.getElementById('video');
let cam=null;
async function startCamera(){
  if(cam) return;
  cam=new Camera(video,{onFrame: async()=> video.readyState>=2 && hands.send({image:video}), width:480, height:360});
  cam.start();
}
addEventListener('click',startCamera,{once:true});

// Touch fallback
let touchX=0, touchY=0, touchScale=1;
document.addEventListener('touchmove',e=>{
  if(e.touches.length===1){
    const t=e.touches[0];
    touchX=(t.clientX/window.innerWidth-0.5)*Math.PI*2;
    touchY=(t.clientY/window.innerHeight-0.5)*Math.PI;
  } else if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    touchScale=Math.sqrt(dx*dx+dy*dy)/200;
  }
});

// Animate
function animate(){
  requestAnimationFrame(animate);
  let rotX=rotationX||(isMobile?touchY:0);
  let rotY=rotationY||(isMobile?touchX:0);
  particles.rotation.x+=(rotX-particles.rotation.x)*0.05;
  particles.rotation.y+=(rotY-particles.rotation.y)*0.05;
  let scl=isMobile?touchScale:scale;
  particles.scale.setScalar(scl);

  for(let i=0;i<COUNT;i++){
    let dx=vortexCenter.x-positions[i*3];
    let dy=vortexCenter.y-positions[i*3+1];
    let dz=vortexCenter.z-positions[i*3+2];
    let dist=Math.sqrt(dx*dx+dy*dy+dz*dz)+0.001;
    let force=(isMobile?0.008:0.02)/dist;
    velocities[i*3]+=dx*force;
    velocities[i*3+1]+=dy*force;
    velocities[i*3+2]+=dz*force;
    positions[i*3]+=velocities[i*3];
    positions[i*3+1]+=velocities[i*3+1];
    positions[i*3+2]+=velocities[i*3+2];
    velocities[i*3]*=0.95; velocities[i*3+1]*=0.95; velocities[i*3+2]*=0.95;
    colors[i*3]=0.5+0.5*Math.sin(performance.now()*0.002+colorShift);
  }

  geometry.attributes.position.needsUpdate=true;
  geometry.attributes.color.needsUpdate=true;
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>


